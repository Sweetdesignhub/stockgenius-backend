let HSWebSocket = require('../HSM_Package/hslib.js');
let mapdata = require("./mapper.js");
let ErrorHandler = require("../errorHandler/errorHandler.js");
let axios = require("axios")
let Logger = require("../logger/log.js")
let { Config } = require("../config/config");
let jwt = require('jsonwebtoken');

const floatkeys = ["ltp", "op", "c", "lo", "h", "cng", "nc", "yh", "yl", "ap", "to", "lcl", "ucl", "bp", "sp", "mul", "prec", "openingPrice", "lowPrice", "highPrice", "ic", "iv","bp1","bp2","bp3","bp4","sp1","sp2","sp3","sp4"]
const intkeys = ["ltq", "v", "tbq", "tsq", "oi", "bq", "bs","bq1","bq2","bq3","bq4","bs1","bs2","bs3","bs4","bno1","bno2","bno3","bno4","bno5","sno1","sno2","sno3","sno4","sno5"]
const datekeys = ["ltt", "fdtm","tvalue"]
const exchmapping = { "1010": 'nse_cm', "1011": 'nse_fo', "1120": 'mcx_fo', "1210": 'bse_cm', "1012": 'cde_fo', "1211": 'bse_fo' ,"1020": 'nse_com', "1212": 'bcs_fo'}
var fulldata = {};

/**
 * returns the overall count of symbol subscribed across all channels.
 * @param {Object} symbolcounter - symbolcounter object which has subscription type as keys and values as object having key as channel number and values as list of exchange token of symbols subscribed on channel.
 * @returns {Number} number of symbols subscribed over all channels.
 */
function countValues(symbolcounter) {
	return Object.values(symbolcounter).reduce((count, innerObject) => {
		return count + Object.values(innerObject).reduce((sum, list) => {
			return sum + list.length;
		}, 0);
	}, 0);
}

/**
 * used to send http request to quotes api to get FYtoken.
 * @param {Array} urls - premade urls with querys.
 * @param {string} AuthrizationToken - AccessToken of user.
 * @param {Function} callback - the callback function.
 * @param {Logger} logger - logger class.
 * @returns {Object} with key as symbol ticker and value as fytoken
 */
async function sendRequests(urls, AuthrizationToken, callback, logger) {
	var funcname = "sendRequests"
	var symboltokenmap = {}
	var resp = undefined
	for (const url of urls) {
		try {
			const response = await axios.get((url), {
				headers: {
					Authorization: AuthrizationToken,
				}
			});
			resp = response.data
		} catch (error) {
			var err = new ErrorHandler(error).getError()
			logger.error("error fetching symbol token", err, funcname)
			err['type'] = "sub"
			callback(err)
			resp = { 'd': [] }
		}
		resp = resp.d
		resp.forEach(function (element) {//make a object with symbol as key and fytoken as value
			if (element.s === 'ok') {
				symboltokenmap[element.n] = element.v.fyToken
			} else {
				callback({ "code": element.v.code, "type": "sub", "message": element.v.errmsg, "s": element.v.s, "symbol": element.n })
				logger.error("error fetching symbol token for specific symbol", element, funcname)
			}
		})
	}
	return symboltokenmap
}
/**
 * used to send http request to quotes api to get FYtoken.
 * @param {Array} urls - premade urls with querys.
 * @param {string} AuthrizationToken - AccessToken of user.
 * @param {Function} callback - the callback function.
 * @param {Logger} logger - logger class.
 * @returns {Object} with key as symbol ticker and value as fytoken
 */
async function getFyToken(url , AuthrizationToken , bodies , logger ,callback) {
	var resp = null;
	var returnResponse = {}
	const funcname = "getFyToken";
	for (const body of bodies){
		var requestBody = JSON.stringify(body)
		try {
			const response = await axios.post((url),requestBody, {
				headers: {
					Authorization: AuthrizationToken,
				}
			});
			resp = response.data
			for (key in resp['validSymbol']){
				returnResponse[key] = resp['validSymbol'][key]
			}
			
		} catch (error) {
			var err = new ErrorHandler(error).getError()
			logger.error("error fetching symbol token", err, funcname)
			err['type'] = "sub"
			callback(err)
			resp = { 'd': [] }
		}
	}
	return returnResponse
}

/**
 * function called to check if one single symbol is not subscribed on multiple channels before deleting its in-memory object.
 * @param {Object} obj - premade urls with querys.
 * @param {string} value - AccessToken of user.
 * @returns {boolean} true if symbol found subscribed on multiple channels
 */
function checkValueInLists(obj, value) {
	let count = 0;
	let foundMultiple = false;

	for (const key in obj) {
		if (Array.isArray(obj[key]) && obj[key].includes(value)) {
			count++;
			if (count > 1) {
				foundMultiple = true;
				break;
			}
		}
	}

	return !foundMultiple;
}

/**
 * appends data to Array dropping duplicates
 * @param {Array} mainList - array to which value is to be appened.
 * @param {any} valueToAppend - value to be appended to array.
 * @returns {Array} Appened array.
 */
function appendToList(mainList, valueToAppend) {
	if (!mainList.includes(valueToAppend)) {
		mainList.push(valueToAppend);
	}
	return mainList;
}

/**
 * return array dropping value passed in channelnumber from default channel list or whatever array passed
 * @param {any} channelnumber - value to be dropped from array.
 * @param {Array} channellist - array from which valued to be dropped.
 * @returns {Array} array dropping the value.
 */
function returnstopchannelarray(channelnumber, channellist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]) {
	for (var i = 0; i < channellist.length; i++) {

		if (channellist[i] === channelnumber) {

			channellist.splice(i, 1);
		}
	}
	return channellist
}

/**
 * return array as array of arrays splitting input array to length of limit
 * @param {Array} array - array to be split.
 * @param {Number} limit - array length limit.
 * @returns {Array<Array<any>>} array dropping the value.
 */
function splitArray(array, limit) {
	const result = [];
	let currentArray = [];

	for (const item of array) {
		currentArray.push(item);

		if (currentArray.length === limit) {
			result.push(currentArray);
			currentArray = [];
		}
	}

	if (currentArray.length > 0) {
		result.push(currentArray);
	}

	return result;
}

/**
 * return array as array of arrays splitting input array to length of limit
 * @param {string} datestring - datestring to convert to epoch time.
 * @returns {Number} epoch time.
 */
function DateTimeStringToEpoch(datestring) {
	process.env.TZ = 'Asia/Kolkata';
	// Parse the date string into its components
	const [day, month, year, hours, minutes, seconds] = datestring.match(/\d+/g);
	// Create a new Date object with the components (months are zero-based)
	const date = new Date(year, month - 1, day, hours, minutes, seconds);
	// Get the epoch time in seconds by dividing by 1000 and flooring the result
	const epochTimeSec = Math.floor(date.getTime() / 1000);
	return epochTimeSec
}
/**
 * Class to make a queue datatype object(makes a first in first out system using array).
 * @class
 */
class Queuesystem {
	constructor() {
		this.queue = [];
	}
	/**
	 * used to add data to queue
	 * @param {Object | Object[]} data - data to be sent to queue.
	 */
	send(data) {
		this.queue.push(data);
	}

	/**
	 * used to add data to queue
	 * @returns {Promise} A promise that resolves and send data out of queue or undefined in case queue is empty 
	 */
	async receive() {
		if (this.queue.length > 0) {
			return this.queue.shift();
		} else {
			return undefined;
		}
	}
	/**
	 * clears the queue
	 */
	clear() {
		this.queue = []
	}
}

/**
 * function to rename keys of the object
 * @param {Object} obj - object in which key is to be replaced.
 * @param {string} oldKey - the key which is to be renamed.
 * @param {string} newKey - new key name.
 */
function renameObjectKey(obj, oldKey, newKey) {
	if (oldKey !== newKey && obj.hasOwnProperty(oldKey)) {
		obj[newKey] = obj[oldKey];
		delete obj[oldKey];
	}
}

/**
 * maps data from HSM fromat to our format based on channel mode(full/lite) Note:it deletes key if mapping is not found in mapper object.
 * @param {Object} hsminputdata - data from HSM.
 * @param {Boolean} islitemode - true if channel in lite mode else false.
 */
function Mapper(hsminputdata, islitemode) {
	var datatobemapped = { ...hsminputdata }
	var feed_type = datatobemapped.name
	if (feed_type === undefined) {
		feed_type = "confirmationmapper"
	}
	if (islitemode) {
		var mode = "lite"
	} else {
		var mode = "full"
	}
	for (const key in datatobemapped) {
		if (!(mapdata[feed_type] === undefined)) {
			if (!(mapdata[feed_type][mode][key] === undefined)) {
				renameObjectKey(datatobemapped, key, mapdata[feed_type][mode][key]);
				if (feed_type=='sf' && mode=='full') {
					datatobemapped['lower_ckt']=0
					datatobemapped['upper_ckt']=0
				}
			}
			else if (key != "symbol") {
				delete datatobemapped[key]
			}
		}
	}
	return datatobemapped
}

Array.prototype.contains = function (obj) {
	var i = this.length;
	while (i--) {
		if (this[i] === obj) {
			return true;
		}
	}
	return false;
}

let reviver = function (key, value) {
	if (floatkeys.contains(key)) {
		return parseFloat(value)
	} else if (intkeys.contains(key)) {
		return parseInt(value)
	} else if (datekeys.contains(key)) {
		return DateTimeStringToEpoch(value)
	} else {
		return value
	}
}

function decodeJWTAndExtractHSMKey(AccessToken,Logger) {
	const funcname="decodeJWTAndExtractHSMKey"
	try {
		const tokenParts = AccessToken.split(':');
		const jwtToken = tokenParts[tokenParts.length - 1];
		const decodedToken = jwt.decode(jwtToken);

		if (!decodedToken || !decodedToken.hsm_key) {
			Logger.error("HSM key not found in token", decodedToken, funcname)
			throw new Error('Invalid JWT: "hsm_key" missing or token is invalid.');
		}
		if (decodedToken.exp && Date.now() >= decodedToken.exp * 1000) {
			Logger.error("Token expired", decodedToken, funcname)
			throw new Error('You are passing an expired token');
		  }
		return decodedToken.hsm_key;
	} catch (error) {
		Logger.error("HSM key not found in token", error.message, funcname)
		throw new Error(`Failed to decode JWT: ${error.message}`);
	}
}

const _receiver = Symbol('receiver');
const _recurssivesend = Symbol('recursivesend');

const DataSocket = (() => {
	/**
	 * The current channel being used.
	 * @private
	 * @type {Number}
	 */
	let currentchannel = undefined;

	/**
	 * @typedef {object} symbolcounterobj
	 * @property {number} channel  - The number of channel.
	 * @property {Array} symbols - symbols subscribed on channel.
	 */
	/**
	 * The symbol subscribed on a particular channel by subsciption type(dp-depth,if-index,sf-equity & FNO).
	 * @private
	 * @type {symbolcounterobj}
	 */
	let symbolcounter = {
		"if": { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [], 11: [], 12: [], 13: [], 14: [], 15: [], 16: [], 17: [], 18: [], 19: [], 20: [], 21: [], 22: [], 23: [], 24: [], 25: [], 26: [], 27: [], 28: [], 29: [], 30: [] },
		"sf": { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [], 11: [], 12: [], 13: [], 14: [], 15: [], 16: [], 17: [], 18: [], 19: [], 20: [], 21: [], 22: [], 23: [], 24: [], 25: [], 26: [], 27: [], 28: [], 29: [], 30: [] },
		"dp": { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [], 11: [], 12: [], 13: [], 14: [], 15: [], 16: [], 17: [], 18: [], 19: [], 20: [], 21: [], 22: [], 23: [], 24: [], 25: [], 26: [], 27: [], 28: [], 29: [], 30: [] }
	};

	/**
	 * @typedef {object} litemodestatusobj
	 * @property {number} channel  - The number of channel.
	 * @property {Boolean} litemode - true if channel in lite mode.
	 */
	/**
	 * object stating if the channel is in lite mode or not.
	 * @private
	 * @type {litemodestatusobj}
	 */
	let litemodestatus = {
		1: true, 2: true, 3: true, 4: true, 5: true, 6: true, 7: true, 8: true, 9: true, 10: true, 11: false, 12: false, 13: false, 14: false, 15: false, 16: false, 17: false, 18: false, 19: false, 20: false, 21: false, 22: false, 23: false, 24: false, 25: false, 26: false, 27: false, 28: false, 29: false, 30: false
	};

	/**
	 * AccessToken of user.
	 * @private
	 * @type {String}
	 */
	let AccessToken = undefined

	/**
	 * HSMtoken of user.
	 * @private
	 * @type {String}
	 */
	let HSMToken = undefined

	/**
	 * WebsocketURL.
	 * @private
	 * @type {String}
	 */
	let wsURL = Config['HSM_SOCKET'];

	/**
	 * number of max reconnections allowed.
	 * @private
	 * @type {Number}
	 */
	let maxreconnectiontries = 0;

	let reconnectiontries = 0;
	/**
	 * count of number of request sent to socket in a second reset to zero every second.
	 * @private
	 * @type {Number}
	 */
	let secondcounter = 0;

	/**
	 * HSM websocket object.
	 * @private
	 * @type {HSWebSocket}
	 */
	let hsSocket = new HSWebSocket();

	/**
	 * makes a queue variable to push data to send to websocket.
	 * @private
	 * @type {Queuesystem}
	 */
	let queue = new Queuesystem();

	/**
	 * Class to access symboldata websocket.
	 * @class
	 */
	class DataSocket {

		/**
		 * Create a new DataSocket object to acess symboldata websocket.
		 * @constructor
		 * @param {Object} params - The parameters for initializing the DataSocket.
		 * @param {string} Token - The access token for authentication.
		 * @param {string} [path] - The path for log files.
		 */
		constructor(Token,path,loggingFlag=true) {

			if (DataSocket.instance) {
				throw new Error("Only one instance of DataSocket is allowed. Use getInstance() instead.");
			}
			var self = this;

			/**
			 * variable to be passed to make channel run in full mode.
			 * @type {string}
			 */
			self.FullMode = "ful"

			/**
			 * filepath where are logs are to be saved.
			 * @type {string}
			 */
			self.LogPath = path;

			/**
			 * Flag to enable or disable logging.
         	 * @type {boolean}
			 */
			self.LoggingFlag = loggingFlag;

			/**
			 * object used to write logs.
			 * @type {Logger}
			 */
			self.Logger = new Logger(this.LogPath,this.LoggingFlag)

			/**
			 * variable to be passed to make channel run in lite mode.
			 * @type {string}
			 */
			self.LiteMode = "lit"
			AccessToken = Token;
			HSMToken = decodeJWTAndExtractHSMKey(AccessToken,self.Logger);

			/**
			 * saves the final onopen function after adding necessary changes to callback function provided by user.
			 * @type {Function}
			 */
			self.socketonOpen = undefined;

			/**
			 * saves the final onmessage function after adding necessary changes to callback function provided by user.
			 * @type {Function}
			 */
			self.onticks = undefined;

			/**
			 * saves the final onerror function after adding necessary changes to callback function provided by user.
			 * @type {Function}
			 */
			self.socketonerror = undefined;

			/**
			 * saves the final onclose function after adding necessary changes to callback function provided by user.
			 * @type {Function}
			 */
			self.socketonclose = undefined;

			/**
			 * saves the raw on message function provided by user.
			 * @type {Function}
			 */
			self.callbackfunction = function (message) { console.log({ "SocketMessage": message }) };

			//resets second counter every second.
			self.secondcountertimer= setInterval(() => {
				secondcounter = 0;
			}, 1000);

			/**
			 * saves set interval timer that runs pushing data out of the queue(wont push data out if ratelimit is breached) to send it to socket.
			 * @type {NodeJS.Timer}
			 */
			self.interval = undefined

			/**
			 * saves set interval timer that runs autoreconnect mechanism in case user has enabled auto reconnect.
			 * @type {NodeJS.Timer}
			 */
			self.autreconnecttimer = undefined
			
			self.autoreconnectflag = false

			self.isUserClosed = false

			DataSocket.instance = this;
		}
		/**
		 * @returns {DataSocket}
		 */

		static getInstance(Token,path,loggingFlag=true) {
			if (!DataSocket.instance) {
				DataSocket.instance = new DataSocket(Token,path,loggingFlag);

			}
			return DataSocket.instance;
		}

		/**
		 * pushes data out of queue.
		 * @returns {Promise<void>} - A promise that resolves when data is recieved from queue.
		 */
		async[_receiver]() {
			const data = await queue.receive();
			return data
		}

		/**
		 * interval variable of class runs this function to send data to socket that is pushed out of queue.
		 */
		[_recurssivesend]() {
			const funcname = "recurssivesend"
			const logger = this.Logger
			try {
				if (secondcounter > 10 || !(hsSocket.isConnected())) {//if second ratelimit is breached
					return
				} else {
					this[_receiver]().then(async (response) => {//pushes data out of queue and recieves
						if (response === undefined) {
							return
						} else {
							if (response.constructor === Array) {//if pushed data is array iterate over array and send over socket(some request grouped as array to stop race condition as whenever subscribed to a new channel it is resumed and rest of channels are paused multiple subscribe or unsubscibe at a time raised resuming of unrequired channel)
								response.forEach(async element => {
									if (element.type === 'ifs' || element.type === 'ifu' || element.type === 'mws' || element.type === 'mwu' || element.type === 'dps' || element.type === 'dpu') {//whenever any subscribe unsubscribe request made make its channel as current channel
										currentchannel = element.channelnum
									}
									await this.waitFor(500)
									hsSocket.send(JSON.stringify(element))
									secondcounter++
								});
							}
							else {
								if (response.type === 'ifs' || response.type === 'ifu' || response.type === 'mws' || response.type === 'mwu' || response.type === 'dps' || response.type === 'dpu') {//whenever any subscribe unsubscribe request made make its channel as current channel
									currentchannel = response.channelnum
								}
								await this.waitFor(500)
								hsSocket.send(JSON.stringify(response))
								secondcounter++
							}
						}
					});
				}
			}
			catch (error) {
				logger.error("error in recurrsivefunction", error, funcname)
			}
		}
 
		waitFor = function wait(ms){
			return new Promise(resolve => {
				setTimeout(resolve, ms);
			  });
		}

		/**
		 * used to define onmessage,onerror,onopen,onclose for websocket.
		 * @param {string} onwhat - defines for what the callback function is.
		 * @param {Function} callback - the callback function.
		 * @throws  error message if onwhat is not valid.
		 */
		on = function (onwhat, callback) {
			const funcname = "on"
			const logger = this.Logger
			try {
				var que = queue
				if (onwhat === "connect") {
					var akstkn = HSMToken
					this.socketonOpen = function () {
						reconnectiontries = 0 //resets reconnection count if reconnected
						que.send({ "type": "cn", "sessionid": akstkn, "mode": "P" })//sends message on queue to authorize user
						callback()
					}
					hsSocket.onOpen = this.socketonOpen//set classes socketonOpen varibale to hssocket.onOpen
				}
				else if (onwhat === "message") {

					this.callbackfunction = callback
					var errorcallback = this.socketonerror
					this.onticks = function (message) {
						try {
							var Objmessage = JSON.parse(message, reviver) // parses incoming data as object
							logger.debug("HSM raw data", Objmessage, "conversion")
							Objmessage.forEach(function (element) {
								if (element.stat === undefined) {
									if (element.tk != "") {
										delete element.ts // deleteing symbol provided by HSM as we are mapping our own format symbol
										fulldata[element.tk][element.name] = Object.assign({}, fulldata[element.tk][element.name], element)//updates data to fulldata variable which has full tick data stored in memory
										var ouptput_to_be_sent = Mapper(fulldata[element.tk][element.name], litemodestatus[currentchannel])//Maps data from HSM format to our format and format data according to full/lite mode
										callback(ouptput_to_be_sent)
									}
								} else {

									var returnmessage = Mapper(JSON.parse(message)[0], litemodestatus[currentchannel])//format success/error response to our format from HSM
									if (returnmessage["s"] === 'Ok') {
										returnmessage["s"] = 'ok'
										callback(returnmessage)
									} else {
										returnmessage["s"] = 'error'
										errorcallback(returnmessage)
										return
									}
								}
							})
							
						} catch (error) {
							logger.error("error converting message", {"error":error}, "conversion")
						}
					}
					hsSocket.onMessage = this.onticks
				}
				else if (onwhat === "error") {
					this.socketonerror = function (message) {
						callback(message)
					}
					hsSocket.onError = this.socketonerror
				}
				else if (onwhat === "close") {
					this.socketonclose = function () {
						callback()
						clearInterval(DataSocket.instance.interval)
						if(!DataSocket.instance.isUserClosed && (reconnectiontries < maxreconnectiontries)){
							DataSocket.instance._autoreconnect()
						}else{
							clearInterval(DataSocket.instance.secondcountertimer)
						}
					}
					hsSocket.onClose = this.socketonclose
				}
				else {
					console.error("invalid parameter:", onwhat)
					logger.error("invalid parameter:", { "input": onwhat }, funcname)
				}
			}
			catch (error) {
				logger.error("error in on function", error, funcname)
			}
		}

		/**
		 * called to connect to the data socket
		 */
		connect = function () {
			const funcname = "connect"
			const logger = this.Logger
			try {
				this.interval = setInterval(() => {//start [_recurssivesend] function to get data from queue and send to websocket 
					this[_recurssivesend]();
				}, 1);
				var akstkn = this.HSMToken
				var que = queue
				if (this.socketonOpen === undefined) {//default callback function incase not passed by user
					hsSocket.onOpen = function () {
						console.log("connected")
						reconnectiontries = 0
						que.send({ "type": "cn", "sessionid": akstkn, "mode": "P" })
					}
					this.socketonOpen = hsSocket.onOpen
				} else {
					hsSocket.onOpen = this.socketonOpen
				}

				if (this.onticks === undefined) {//default callback function incase not passed by user
					hsSocket.onMessage = function (message) {
						var Objmessage = JSON.parse(message, reviver)
						Objmessage.forEach(function (element) {
							if (element.stat === undefined) {
								delete element.ts
								fulldata[element.tk][element.name] = Object.assign({}, fulldata[element.tk][element.name], element)

								var ouptput_to_be_sent = Mapper(fulldata[element.tk][element.name], litemodestatus[currentchannel])
								console.log({ "SocketMessage": ouptput_to_be_sent })

							} else {
								var returnmessage = [Mapper(JSON.parse(message)[0], litemodestatus[currentchannel])]
								if (returnmessage[0]["s"] === 'Ok') {
									returnmessage[0]["s"] = 'ok'
									console.log({ "SocketMessage": returnmessage })
								} else {
									returnmessage[0]["s"] = 'error'
									console.log({ "SocketMessage": returnmessage })
									return
								}
							}
						})
					}
				} else {
					hsSocket.onMessage = this.onticks
				}

				if (this.socketonclose === undefined) {//default callback function incase not passed by user
					hsSocket.onClose = function () {
						clearInterval(DataSocket.instance.interval);
						console.log("ws closed")
						if(!DataSocket.instance.isUserClosed && (reconnectiontries < maxreconnectiontries)){
							DataSocket.instance._autoreconnect()
						}else{
							clearInterval(DataSocket.instance.secondcountertimer)
						}
					}
					this.socketonclose = hsSocket.onClose
				} else {
					hsSocket.onClose = this.socketonclose
				}
				if (this.socketonerror === undefined) {//default callback function incase not passed by user
					hsSocket.onError = function (message) {
						console.log("error occoured")
						if (message != undefined) {
							console.log({ "Socketerror": message })
						}
					}
					this.socketonerror = hsSocket.onError
				} else {
					hsSocket.onError = this.socketonerror
				}
				hsSocket.connect(wsURL); //connects to websocket
			}
			catch (error) {
				logger.error(("error in on connect function", error, funcname))
			}
		}

		/**
		 * Subscribe to a symbol.
		 * @param {Array} req - array of symbols to subscribe to.
		 * @param {Boolean} [depth=false] - true if you want to subscribe for marketdepth data do not pass it true for index as they dont have marketdepth data.
		 * @param {Number} [channelnumber=11] - Channel you want to subscribe on(Warning do not pass any value for this if you dont know the significance).
		 */
		subscribe = async (req, depth = false, channelnumber = 11) => {
			const funcname = "subscribe"
			const logger = this.Logger
			try {
				var callback = this.socketonerror
				if (channelnumber <= 0 || channelnumber > 30) {
					callback({ "code": -99, "type": "sub", "message": "channel can be in range 1 to 30", "s": "error" })//sends this on error callback
					logger.error("channel passed out of range", { "code": -99, "type": "sub", "message": "channel can be in range 1 to 30", "s": "error" }, funcname)
					return
				}
				var subscribeCountOverAllChannels = countValues(symbolcounter)
				if (req.length + subscribeCountOverAllChannels > 5000) {
					logger.error("symbol limit passed", { "code": -351, "type": "sub", "message": `subscription limit exceeding you have ${5000 - subscribeCountOverAllChannels} ws subscription left across all channels`, "s": "error" }, funcname)
					callback({ "code": -351, "type": "sub", "message": `subscription limit exceeding you have ${5000 - subscribeCountOverAllChannels} ws subscription left across all channels`, "s": "error", "count": 5000 - subscribeCountOverAllChannels })
					return
				}
				var alreadySubscribedCount = symbolcounter["if"][channelnumber].length + symbolcounter["dp"][channelnumber].length + symbolcounter["sf"][channelnumber].length
				if (req.length + alreadySubscribedCount > 5000) {
					logger.error("symbol limit passed", { "code": -351, "type": "sub", "message": `subscription limit exceeding you have ${5000 - alreadySubscribedCount} ws subscription left`, "s": "error" }, funcname)
					callback({ "code": -351, "type": "sub", "message": `subscription limit exceeding you have ${5000 - alreadySubscribedCount} ws subscription left`, "s": "error", "count": 5000 - alreadySubscribedCount })
					return
				}
				var indexdata = []
				var symboldata = []
				const delay = ms => new Promise(resolve => setTimeout(resolve, ms))
				if (hsSocket === undefined) {
					await delay(1000)
				} else if (!(hsSocket.isConnected())) {//waits in case socket is not open till very first subscribe call
					await delay(1000)
				}
				if (hsSocket === undefined) {
					callback({ "code": -99, "type": "sub", "message": "initalize the socket first", "s": "error" })
					logger.error("socket not initalized", { "code": -99, "type": "sub", "message": "initalize the socket first", "s": "error" }, funcname)
					return
				} else if (!(hsSocket.isConnected())) {
					logger.error("socket is disconnected", { "code": -99, "type": "sub", "message": "socket is disconnected", "s": "error" }, funcname)
					callback({ "code": -99, "type": "sub", "message": "socket is disconnected", "s": "error" })
					return
				}

				var AuthrizationToken = AccessToken
				var splitlist = splitArray(req, 500)
				var bodies = []
				splitlist.forEach(element=>{
					var body = {
						"symbols":element
					}
					bodies.push(body)
				})

				const url = "https://api-t1.fyers.in/data/symbol-token"
				var symboltokenmap = await getFyToken(url, AuthrizationToken, bodies , logger, callback)

				for (const [key, value] of Object.entries(symboltokenmap)) {
					if(value==undefined){
						continue;
					}
					var splitkey = key.split('-')
					if (splitkey[splitkey.length - 1] === "INDEX") {
						var instrexg = value.slice(0, 4)//take exchange and segment from fytoken
						var exch = exchmapping[instrexg]//decide exchange name according to HSM based on exchange & segment
						var exchangetoken = mapdata["index_dict"][key]//take symbol name for index required by HSM from our own symbol ticker
						var scripvalue = exch + '|' + exchangetoken
						if (exchangetoken === undefined) {
							callback({ "code": -15, "type": "sub", "message": "Please provide valid symbol", "s": "error", "symbol": key })
							logger.error("map key not found for index", { "symbol": key }, funcname)
						} else {
							if (depth) {
								callback({ "code": -99, "type": "sub", "message": "Index dont have marketdepth", "s": "error" })
								logger.error("map key not found for index", { "code": -99, "type": "sub", "message": "Index dont have marketdepth", "s": "error" }, funcname)
							} else {
								if (fulldata[exchangetoken] === undefined) {
									fulldata[exchangetoken] = {}
								}
								if (fulldata[exchangetoken]['if'] === undefined) {
									fulldata[exchangetoken]['if'] = { 'symbol': key }
								}
								if (fulldata[exchangetoken]['if']['symbol'] === undefined) {
									fulldata[exchangetoken]['if']['symbol'] = key
								}
								indexdata.push(scripvalue)//push data to indexdata array
								symbolcounter["if"][channelnumber] = appendToList(symbolcounter["if"][channelnumber], exchangetoken)//add to symbol counter
							}
						}
					} else {
						var exchangetoken = value.substring(10);//take exchange token from fytoken
						var instrexg = value.slice(0, 4)// taking exchange & segment values from fytoken
						var exch = exchmapping[instrexg]
						var scripvalue = exch + '|' + exchangetoken
						if (depth) {
							var typeis = "dp"
							// make mapping in fulldata
							if (fulldata[exchangetoken] === undefined) {
								fulldata[exchangetoken] = {}
							}
							if (fulldata[exchangetoken][typeis] === undefined) {
								fulldata[exchangetoken][typeis] = { 'symbol': key }
							}
							if (fulldata[exchangetoken][typeis]['symbol'] === undefined) {
								fulldata[exchangetoken][typeis]['symbol'] = key
							}
						} else {
							var typeis = "sf"
							if (fulldata[exchangetoken] === undefined) {
								fulldata[exchangetoken] = {}
							}
							if (fulldata[exchangetoken][typeis] === undefined) {
								fulldata[exchangetoken][typeis] = { 'symbol': key }
							}
							if (fulldata[exchangetoken][typeis]['symbol'] === undefined) {
								fulldata[exchangetoken][typeis]['symbol'] = key
							}
						}
						symboldata.push(scripvalue)//push to symbol data
						//adding to symbol counter to know how many symbols are subscribed on each channel for each type that is index/depth/regular&FNO
						symbolcounter[typeis][channelnumber] = appendToList(symbolcounter[typeis][channelnumber], exchangetoken)
					}
				}
				var requests = []
				//if there is any index to subscribe to
				if (indexdata.length != 0) {
					//split array bigger than length 1500 into array of length 1500
					const splitindexdata = splitArray(indexdata, 1500)
					splitindexdata.forEach(element => {
						var scripstring = ""
						element.forEach(subelement => {
							//making & seperated string of symbols to send on socket
							scripstring = scripstring + subelement + "&"
						});
						scripstring = scripstring.slice(0, -1)
						//push it to the queue to be sent to socket
						requests.push({
							"type": "ifs",
							"scrips": scripstring,
							"channelnum": channelnumber
						})
					});
				}
				//if there is any stock or FNO to subscribe to
				if (symboldata.length != 0) {
					//split array bigger than length 1500 into array of length 1500
					const splitsymboldata = splitArray(symboldata, 1500)
					splitsymboldata.forEach(element => {
						var scripstring = ""
						element.forEach(subelement => {
							//making & seperated string of symbols to send on socket
							scripstring = scripstring + subelement + "&"
						});
						scripstring = scripstring.slice(0, -1)

						if (depth) {
							var typeval = "dps"
						} else {
							var typeval = "mws"
						}
						requests.push({
							"type": typeval,
							"scrips": scripstring,
							"channelnum": channelnumber
						})
					});
				}
				//once all requests appended to requests array if there is a current channel change we send pause for every other channel and resume for current channel
				if (requests.length != 0) {
					var pauselist = returnstopchannelarray(channelnumber)
					if (channelnumber != currentchannel) {
						requests.push({
							"type": "cp",
							"channelnums": pauselist
						})
						requests.push({
							"type": "cr",
							"channelnums": [channelnumber]
						})
					}
					//sending to queue as a array so one request is sent after another as a group on socket
					queue.send(requests)
				}
			}
			catch (error) {
				logger.error("error in subscribe function", error, funcname)
			}
		}

		/**
		 * Unsubscribe from a symbol(s).
		 * @param {Array} req - array of symbols to subscribe to.
		 * @param {Boolean} [depth=false] - true if you want to subscribe for marketdepth data do not pass it true for index as they dont have marketdepth data.
		 * @param {Number} [channelnumber=11] - Channel you want to subscribe on(Warning do not pass any value for this if you dont know the significance).
		 */
		unsubscribe = async (req, depth = false, channelnumber = 11) => {
			const funcname = "unsubscribe"
			const logger = this.Logger
			try {
				var callback = this.socketonerror
				if (channelnumber <= 0 || channelnumber > 30) {
					callback({ "code": -99, "type": "sub", "message": "channel can be in range 1 to 30", "s": "error" })
					logger.error("channel passed out of range", { "code": -99, "type": "sub", "message": "channel can be in range 1 to 30", "s": "error" }, funcname)
					return
				}
				var indexdata = []
				var symboldata = []
				var delobj = []
				if (hsSocket === undefined) {
					callback({ "code": -99, "type": "sub", "message": "initalize the socket first", "s": "error" })
					logger.error("socket not initalized", { "code": -99, "type": "sub", "message": "initalize the socket first", "s": "error" }, funcname)
					return
				}
				else if (!(hsSocket.isConnected())) {
					callback({ "code": -99, "type": "sub", "message": "socket is disconnected", "s": "error" })
					logger.error("socket is disconnected", { "code": -99, "type": "sub", "message": "socket is disconnected", "s": "error" }, funcname)
					return
				}
				var AuthrizationToken = AccessToken
				var splitlist = splitArray(req, 500)
				var bodies = []

				splitlist.forEach(element=>{
					var body = {
						"symbols":element
					}
					bodies.push(body)
				})

				const url = "https://api-t1.fyers.in/data/symbol-token"
				var symboltokenmap = await getFyToken(url, AuthrizationToken, bodies , logger, callback)
				for (const [key, value] of Object.entries(symboltokenmap)) {
					if(value==undefined){
						continue;
					}
					var splitkey = key.split('-')
					if (splitkey[splitkey.length - 1] === "INDEX") {
						//getting exchange and segement from fytoken and deciding its values as required by HSM
						var instrexg = value.slice(0, 4)
						var exch = exchmapping[instrexg]
						//getting index name in format as required by HSM
						var exchangetoken = mapdata["index_dict"][key]
						var scripvalue = exch + '|' + exchangetoken
						if (exchangetoken === undefined) {
							callback({ "code": -15, "type": "sub", "message": "Please provide valid symbol", "s": "error", "symbol": key })
							logger.error("map key not found for index", { "symbol": key }, funcname)
						} else {
							if (depth) {
								callback({ "code": -99, "type": "sub", "message": "Index dont have marketdepth", "s": "error" })
								logger.error("map key not found for index", { "code": -99, "type": "sub", "message": "Index dont have marketdepth", "s": "error" }, funcname)
							} else {
								var delval = "if"
								indexdata.push(scripvalue)
								delobj.push({ "exchangetoken": exchangetoken, "delval": delval })
							}
						}
					} else {
						if (depth) {
							var delval = "dp"
						} else {
							var delval = "sf"
						}
						//getting exchange token from fytoken
						var exchangetoken = value.substring(10);
						var instrexg = value.slice(0, 4)
						var exch = exchmapping[instrexg]
						var scripvalue = exch + '|' + exchangetoken
						symboldata.push(scripvalue)
						delobj.push({ "exchangetoken": exchangetoken, "delval": delval })
					}
				}

				var requests = []
				if (indexdata.length != 0) {
					// splitting requested array into sub array of length 1500 
					const splitindexdata = splitArray(indexdata, 1500)
					splitindexdata.forEach(element => {
						var scripstring = ""
						element.forEach(subelement => {
							//making & seperated string of scrips
							scripstring = scripstring + subelement + "&"
						});
						scripstring = scripstring.slice(0, -1)
						requests.push({
							"type": "ifu",
							"scrips": scripstring,
							"channelnum": channelnumber
						})
					});
				}

				if (symboldata.length != 0) {
					const splitsymboldata = splitArray(symboldata, 1500)

					splitsymboldata.forEach(element => {
						var scripstring = ""
						element.forEach(subelement => {
							scripstring = scripstring + subelement + "&"
						});
						scripstring = scripstring.slice(0, -1)
						if (depth) {
							var typeval = "dpu"
						} else {
							var typeval = "mwu"
						}
						requests.push({
							"type": typeval,
							"scrips": scripstring,
							"channelnum": channelnumber
						})
					});
				}

				//once all requests appended to requests array if there is a current channel change we send pause for every other channel and resume for current channel
				if (requests.length != 0) {
					var pauselist = returnstopchannelarray(channelnumber)
					if (channelnumber != currentchannel) {
						//channel pause request
						requests.push({
							"type": "cp",
							"channelnums": pauselist
						})
						//channel resume request
						requests.push({
							"type": "cr",
							"channelnums": [channelnumber]
						})
					}
					//sending to queue as a array so one request is sent after another as a group on socket
					queue.send(requests)
				}

				//deletes data stored in memory if it is unsubscribed and not subscribed on any other channel 
				if (delobj.length != 0) {
					delobj.forEach(element => {
						if (!(fulldata[element.exchangetoken] === undefined) && checkValueInLists(symbolcounter[delval], element.exchangetoken)) {
							delete fulldata[element.exchangetoken][element.delval]
						}
						symbolcounter[delval][channelnumber] = returnstopchannelarray(element.exchangetoken, symbolcounter[delval][channelnumber])
					})
				}
			}
			catch (error) {
				logger.error("error in unsubscribe function", error, funcname)
			}
		}

		/**
		 * call to close the datasocket.
		 */
		close = function () {
			const funcname = "close"
			const logger = this.Logger
			try {
				if (hsSocket === undefined) {
					console.log("socket already closed")
					return
				} else if (!(hsSocket.isConnected())) {
					console.log("socket already closed")
					return
				} else {
					//stop autoreconnection
					clearInterval(this.autreconnecttimer)
					clearInterval(this.interval)
					clearInterval(this.secondcountertimer)
					
					this.isUserClosed = true

					hsSocket.close();
					// clears inmemory socket data stored
					fulldata = {}
					//clears queue so incase socket resumed by user queue is cleared
					queue.clear()
					logger.debug("socket closed by function", {}, funcname)
				}
			}
			catch (error) {
				logger.error("error in close function", error, funcname)
			}
		}

		/**
		 * call to check if datasocket is connected
		 */
		isConnected = function () {
			if (hsSocket === undefined) {
				return false
			} else if (!(hsSocket.isConnected())) {
				return false
			} else {
				return true
			}
		}

		/**
		 * call to resume a channel pauses all other channel
		 * @param {Number} channelnum - channel number you want to resume.
		 */
		channelresume = function (channelnum) {
			const funcname = "channelresume"
			const logger = this.Logger
			try {
				if (channelnum.constructor === Number) {
					if (channel > 30 || channel < 1) {
						console.log("channel out of range channel should be between 1 and 30")
						logger.error("channel out of range channel should be between 1 and 30", null, funcname)
						return
					}
					var pauselist = returnstopchannelarray(channelnum)
					queue.send([{
						"type": "cp",
						"channelnums": pauselist
					}, {
						"type": "cr",
						"channelnums": [channelnum]
					}])
				} else {
					console.log("pass channel as a number")
				}
			}
			catch (error) {
				logger.error("error in channelresume function", error, funcname)
			}
		}

		/**
		 * call to set channel to full mode or lite mode
		 * @param {string} modestring - The value parameter that can be either object.FullMode or object.LiteMode.
		 * @param {Number|Number[]} channel - channel number you want to set mode for as a number or array of numbers.
		 */
		mode = function (modestring, channel = 11) {
			const funcname = "mode"
			const logger = this.Logger
			try {
				if (channel.constructor === Array) {
					channel.forEach(element => {
						if (element > 30 || element < 1) {
							console.log("channel out of range channel should be between 1 and 30")
							logger.error("channel out of range channel should be between 1 and 30", null, funcname)
							return
						}
					});
					queue.send({
						"type": modestring,
						"channelnums": channel
					})
					if (modestring === "lit") {
						channel.forEach(element => {
							litemodestatus[element] = true
						});
					} else {
						channel.forEach(element => {
							litemodestatus[element] = false
						});
					}
				} else if (channel.constructor === Number) {
					if (channel > 30 || channel < 1) {
						console.log("channel out of range channel should be between 1 and 30")
						logger.error("channel out of range channel should be between 1 and 30", null, funcname)
						return
					}
					queue.send({
						"type": modestring,
						"channelnums": [channel]
					})
					if (modestring === "lit") {
						litemodestatus[channel] = true
					} else {
						litemodestatus[channel] = false
					}
				} else {
					console.log("please pass channel as number or array of numbers")
					logger.error("please pass channel as number or array of numbers", null, funcname)
				}
			}
			catch (error) {
				logger.error("error in mode function", error, funcname)
			}
		}

		/**
		 * call to enable autoreconnect functionality of websocket.
		 */
		_autoreconnect = function(){
			const funcname = "autoreconnect"
			const logger = this.Logger
			if (this.autoreconnectflag){
				var waitSeconds = Math.floor((reconnectiontries+5)/5);
				waitSeconds *= 5;

				try {
					this.autreconnecttimer = setTimeout(() => {
						if ((!(hsSocket.isConnected())) && (reconnectiontries < maxreconnectiontries)) {
							console.log("trying to reconnect ", reconnectiontries + 1)
							reconnectiontries++;
							symbolcounter = {
								"if": { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [], 11: [], 12: [], 13: [], 14: [], 15: [], 16: [], 17: [], 18: [], 19: [], 20: [], 21: [], 22: [], 23: [], 24: [], 25: [], 26: [], 27: [], 28: [], 29: [], 30: [] },
								"sf": { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [], 11: [], 12: [], 13: [], 14: [], 15: [], 16: [], 17: [], 18: [], 19: [], 20: [], 21: [], 22: [], 23: [], 24: [], 25: [], 26: [], 27: [], 28: [], 29: [], 30: [] },
								"dp": { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [], 11: [], 12: [], 13: [], 14: [], 15: [], 16: [], 17: [], 18: [], 19: [], 20: [], 21: [], 22: [], 23: [], 24: [], 25: [], 26: [], 27: [], 28: [], 29: [], 30: [] }
							};
							this.connect()
						} else if (reconnectiontries >= maxreconnectiontries) {
							console.log("max autoconnect tries exceeded")
							reconnectiontries = 0
						}
					}, (waitSeconds)*1000);
				}
				catch (error) {
					logger.error("error in autoreconnect function", error, funcname)
				}
			}
		}

		autoreconnect=function(reConnectTriesCount=5){
			this.autoreconnectflag=true
			maxreconnectiontries = (reConnectTriesCount>50) ? 50 : reConnectTriesCount
		}
	}
	return DataSocket
})();


module.exports = DataSocket